@page "/variables"
@using Configo.Server.Domain
@inject ApplicationManager ApplicationManager
@inject TagGroupManager TagGroupManager
@inject TagManager TagManager
@inject VariableManager VariableManager
@inject SchemaManager SchemaManager
@inject IJSRuntime JsRuntime
@inject ISnackbar Snackbar

<MudText Typo="Typo.h4" GutterBottom="true">
    <MudIcon Icon="@Icons.Material.Filled.SettingsSuggest" Size="Size.Large"/>
    Variables
</MudText>

@if (_tags.Count == 0)
{
    <MudAlert Severity="Severity.Warning">Please create at least one tag</MudAlert>
    return;
}

@if (_applications.Count == 0)
{
    <MudAlert Severity="Severity.Warning">Please create at least one application</MudAlert>
    return;
}

<MudGrid>
    <MudItem sm="12" md="5" lg="4" xl="3">
        <MudCard Square="true" Class="mb-1">
            <MudCardHeader Class="py-2">
                <CardHeaderAvatar>
                    <MudAvatar Size="Size.Small" Variant="Variant.Filled">
                        <MudIcon Size="Size.Small" Icon="@Icons.Material.Filled.Timer"/>
                    </MudAvatar>
                </CardHeaderAvatar>
                <CardHeaderContent>
                    <MudText>Pending changes</MudText>
                </CardHeaderContent>
            </MudCardHeader>
            <MudCardContent Class="py-2 px-4">
                <MudSwitch T="bool"
                           Value="@_showPendingChangesDiff"
                           ValueChanged="isChecked => OnShowPendingChanges((bool?)isChecked)"
                           Color="Color.Primary">
                    Show diff
                </MudSwitch>
                @foreach (var pendingChange in _pendingChanges)
                {
                    var application = _applicationsById[pendingChange.ApplicationId];
                    var tag = _tagsById[pendingChange.TagId];

                    <MudStack Row="true">
                        <MudChip T="string"
                                 Label="true"
                                 Icon="@Icons.Material.Filled.Cloud"
                                 Size="Size.Small"
                                 @onclick="() => OnSelectPendingChange(application, tag)">
                            @application.Name (@tag.GroupName:@tag.Name)
                        </MudChip>
                    </MudStack>
                }
            </MudCardContent>
            <MudCardActions Class="py-2 px-4">
                <MudButtonGroup OverrideStyles="false">
                    <MudButton Color="Color.Success"
                               Size="Size.Small"
                               Variant="Variant.Outlined"
                               Disabled="!_hasPendingChanges"
                               @onclick="SavePendingChanges">
                        <MudIcon Size="Size.Small" Icon="@Icons.Material.Filled.Save"/>
                        Save changes
                    </MudButton>
                    <MudButton Color="Color.Error"
                               Size="Size.Small"
                               Variant="Variant.Outlined"
                               Disabled="!_hasPendingChanges"
                               @onclick="DiscardPendingChanges">
                        <MudIcon Size="Size.Small" Icon="@Icons.Material.Filled.Delete"/>
                        Discard changes
                    </MudButton>
                </MudButtonGroup>
            </MudCardActions>
        </MudCard>

        <MudCard Square="true" Class="mb-1">
            <MudCardHeader Class="py-2">
                <CardHeaderAvatar>
                    <MudAvatar Size="Size.Small" Variant="Variant.Filled">
                        <MudIcon Size="Size.Small" Icon="@Icons.Material.Filled.Cloud"/>
                    </MudAvatar>
                </CardHeaderAvatar>
                <CardHeaderContent>
                    <MudText>Application</MudText>
                </CardHeaderContent>
            </MudCardHeader>
            <MudCardContent Class="py-2 px-4">
                <MudSelect T="int?"
                           Value="_selectedApplicationId"
                           ValueChanged="OnChangeSelectedApplicationId"
                           Variant="Variant.Outlined"
                           Clearable="true"
                           Placeholder="Choose an application"
                           Margin="Margin.Dense"
                           Dense="true">
                    @foreach (var application in _applications)
                    {
                        <MudSelectItem T="int?" Value="@application.Id">@application.Name</MudSelectItem>
                    }
                </MudSelect>
            </MudCardContent>
        </MudCard>

        <MudCard Square="true" Class="mb-1">
            <MudCardHeader Class="py-2">
                <CardHeaderAvatar>
                    <MudAvatar Size="Size.Small" Variant="Variant.Filled">
                        <MudIcon Size="Size.Small" Icon="@Icons.Material.Filled.Tag"/>
                    </MudAvatar>
                </CardHeaderAvatar>
                <CardHeaderContent>
                    <MudText>Tag</MudText>
                </CardHeaderContent>
            </MudCardHeader>
            <MudCardContent Class="py-2">
                <MudSelect T="int?"
                           Value="_selectedTagGroupId"
                           ValueChanged="OnChangeSelectedTagGroupId"
                           Label="Tag group"
                           Placeholder="Choose a tag group"
                           Variant="Variant.Outlined"
                           Clearable="true"
                           Margin="Margin.Dense"
                           Dense="true">
                    @foreach (var tagGroup in _tagGroups)
                    {
                        <MudSelectItem Value="@((int?)tagGroup.Id)">@tagGroup.Name</MudSelectItem>
                    }
                </MudSelect>
                <MudSelect T="int?"
                           Value="_selectedTagId"
                           ValueChanged="OnChangeSelectedTagId"
                           Label="Tag"
                           Placeholder="Choose a tag"
                           Variant="Variant.Outlined"
                           Clearable="true"
                           Margin="Margin.Dense"
                           Dense="true">
                    @foreach (var tag in _availableTags)
                    {
                        <MudSelectItem Value="@((int?)tag.Id)">@tag.Name</MudSelectItem>
                    }
                </MudSelect>
            </MudCardContent>
        </MudCard>
    </MudItem>
    <MudItem sm="12" md="7" lg="8" xl="9">
        <MudCard>
            <MudCardHeader Class="px-2 py-1">
                <MudStack Row="true">
                    @if (SelectedApplication is { } selectedApplication && SelectedTag is { } selectedTag)
                    {
                        <MudChip T="string"
                                 Label="true"
                                 Icon="@Icons.Material.Filled.Cloud"
                                 Color="Color.Primary">
                            @selectedApplication.Name (@selectedTag.GroupName:@selectedTag.Name)
                        </MudChip>
                    }
                </MudStack>
            </MudCardHeader>
            <MudCardContent Class="py-0 px-0">
                @* Editors go here *@
                <div id="variables-editor-container" class="container-fluid" style="min-height: 70vh">

                </div>
                <div id="variables-diff-editor-container" class="container-fluid" style="min-height: 70vh">

                </div>
            </MudCardContent>
        </MudCard>
    </MudItem>
</MudGrid>

@code {
    private DotNetObjectReference<Variables>? _objectReference;
    private List<TagGroupDropdownModel> _tagGroups = [];
    private List<TagDropdownModel> _tags = [];
    private readonly List<TagDropdownModel> _availableTags = [];
    private List<ApplicationModel> _applications = [];
    private bool _showPendingChangesDiff;
    private bool _hasPendingChanges;
    private int? _selectedTagGroupId;
    private int? _selectedTagId;
    private int? _selectedApplicationId;
    private List<VariablesEditModel> _pendingChanges = [];


    private Dictionary<int, ApplicationModel> _applicationsById = [];
    private Dictionary<int, TagDropdownModel> _tagsById = [];

    private TagDropdownModel? SelectedTag => _selectedTagId is null ? null : _tagsById[_selectedTagId.Value];
    private ApplicationModel? SelectedApplication => _selectedApplicationId is null ? null : _applicationsById[_selectedApplicationId.Value];

    protected override async Task OnInitializedAsync()
    {
        _applications = await ApplicationManager.GetAllApplicationsAsync(CancellationToken);
        _applicationsById = _applications.ToDictionary(a => a.Id);
        _tagGroups = await TagGroupManager.GetAllTagGroupsForDropdownAsync(CancellationToken);
        _tags = await TagManager.GetAllTagsForDropdownAsync(CancellationToken);
        _tagsById = _tags.ToDictionary(g => g.Id);
        _hasPendingChanges = await VariableManager.HasPendingChangesAsync(CancellationToken);
        await RefreshPendingChanges();
        await base.OnInitializedAsync();
    }

    public async Task SavePendingChanges()
    {
        await VariableManager.SavePendingChangesAsync(CancellationToken);

        _hasPendingChanges = false;
        _showPendingChangesDiff = false;

        await RefreshPendingChanges();
        await UpdateEditorAsync();

        Snackbar.Add("Pending changes saved successfully", Severity.Success);
    }

    public async Task RefreshPendingChanges()
    {
        _pendingChanges = await VariableManager.GetPendingChangesAsync(CancellationToken);
        _pendingChanges = _pendingChanges
            .Select(p => new { PendingChange = p, Application = _applicationsById[p.ApplicationId], Tag = _tagsById[p.TagId] })
            .OrderBy(p => p.Application.Name).ThenBy(p => p.Tag.GroupOrder).ThenBy(p => p.Tag.Name)
            .Select(p => p.PendingChange)
            .ToList();
    }

    public async Task DiscardPendingChanges()
    {
        await VariableManager.DiscardPendingChangesAsync(CancellationToken);

        _hasPendingChanges = false;
        _showPendingChangesDiff = false;

        await RefreshPendingChanges();
        await UpdateEditorAsync();
    }

    [JSInvokable]
    public async Task Save(string variables)
    {
        if (_selectedTagId is null || _selectedApplicationId is null)
        {
            return;
        }

        await VariableManager.SaveToPendingAsync(new VariablesEditModel
        {
            Json = variables,
            TagId = _selectedTagId.Value,
            ApplicationId = _selectedApplicationId.Value
        }, CancellationToken);

        Snackbar.Add("Variables saved to pending changes", Severity.Success);

        _hasPendingChanges = true;
        await RefreshPendingChanges();
        StateHasChanged();
    }

    protected override async ValueTask OnDisposeAsync()
    {
        if (_objectReference != null)
        {
            try
            {
                await JsRuntime.InvokeVoidAsync("variables.destroy", CancellationToken);
            }
            catch (JSDisconnectedException)
            {
                // Ignore
            }
            finally
            {
                _objectReference?.Dispose();
            }
        }

        await base.OnDisposeAsync();
    }

    private async Task UpdateEditorAsync()
    {
        if (_selectedTagId is null || _selectedApplicationId is null)
        {
            return;
        }

        _objectReference ??= DotNetObjectReference.Create(this);
        var schema = await SchemaManager.GetSchemaAsync(_selectedApplicationId, CancellationToken);
        var isReadonly = _showPendingChangesDiff;
        if (_showPendingChangesDiff)
        {
            var originalConfig = await VariableManager.GetConfigAsync(_selectedTagId.Value, _selectedApplicationId.Value, CancellationToken);
            var modifiedConfig = await VariableManager.GetConfigWithPendingChangesAsync(_selectedTagId.Value, _selectedApplicationId.Value, CancellationToken);
            await JsRuntime.InvokeVoidAsync("variables.updateDiffEditor", CancellationToken, _objectReference, originalConfig, modifiedConfig, schema);
        }
        else
        {
            var config = await VariableManager.GetConfigWithPendingChangesAsync(_selectedTagId.Value, _selectedApplicationId.Value, CancellationToken);
            await JsRuntime.InvokeVoidAsync("variables.updateEditor", CancellationToken, _objectReference, config, schema, isReadonly);
        }
    }

    private async Task OnChangeSelectedTagGroupId(int? selectedTagGroupId)
    {
        _selectedTagGroupId = selectedTagGroupId;
        if (_selectedTagGroupId is { } tagGroupId)
        {
            _availableTags.Clear();
            _availableTags.AddRange(_tags.Where(t => t.GroupId == tagGroupId));

            if (SelectedTag is { } selectedTag && selectedTag.GroupId != tagGroupId)
            {
                _selectedTagId = null;
            }
        }
        else
        {
            _selectedTagId = null;
        }

        await UpdateEditorAsync();
    }

    private async Task OnChangeSelectedTagId(int? selectedTagId)
    {
        _selectedTagId = selectedTagId;
        await UpdateEditorAsync();
    }

    private async Task OnChangeSelectedApplicationId(int? selectedApplicationId)
    {
        _selectedApplicationId = selectedApplicationId;
        await UpdateEditorAsync();
    }

    private async Task OnSelectPendingChange(ApplicationModel application, TagDropdownModel tag)
    {
        await OnChangeSelectedApplicationId(application.Id);
        await OnChangeSelectedTagGroupId(tag.GroupId);
        await OnChangeSelectedTagId(tag.Id);
    }

    private async Task OnShowPendingChanges(bool? value)
    {
        _showPendingChangesDiff = value == true;

        await UpdateEditorAsync();
    }

}
